-- ============================================================================
-- Contextuate Monitor - PostgreSQL Schema
-- ============================================================================
--
-- Production-ready PostgreSQL schema for persistent storage of monitor sessions
-- and events. This schema supports distributed Claude Code monitoring with
-- hierarchical session tracking and efficient event querying.
--
-- Requirements: PostgreSQL 12+ (for native JSONB and better indexing)
-- Features: JSONB for efficient JSON indexing, GIN indexes, partial indexes
-- Charset: UTF-8 (default)
--
-- ============================================================================

-- Drop existing tables (in reverse dependency order)
DROP TABLE IF EXISTS events CASCADE;
DROP TABLE IF EXISTS sessions CASCADE;

-- Create custom types for better type safety
DO $$ BEGIN
  CREATE TYPE session_status AS ENUM ('active', 'completed', 'error');
EXCEPTION
  WHEN duplicate_object THEN null;
END $$;

DO $$ BEGIN
  CREATE TYPE monitor_event_type AS ENUM (
    'session_start', 'session_end', 'tool_call', 'tool_result',
    'message', 'notification', 'thinking', 'error',
    'agent_spawn', 'agent_complete'
  );
EXCEPTION
  WHEN duplicate_object THEN null;
END $$;

DO $$ BEGIN
  CREATE TYPE claude_hook_type AS ENUM (
    'PreToolUse', 'PostToolUse', 'Notification', 'Stop', 'SubagentStop'
  );
EXCEPTION
  WHEN duplicate_object THEN null;
END $$;

-- ============================================================================
-- Sessions Table
-- ============================================================================
--
-- Stores metadata for each Claude Code session, including hierarchical
-- relationships (parent/child sessions) and token usage tracking.
--
CREATE TABLE sessions (
  -- Primary identification
  session_id VARCHAR(255) PRIMARY KEY,

  -- Machine & environment context
  machine_id VARCHAR(255) NOT NULL,
  working_directory TEXT NOT NULL,

  -- Timing information (Unix timestamps in milliseconds)
  start_time BIGINT NOT NULL,
  end_time BIGINT DEFAULT NULL,

  -- Session state
  status session_status NOT NULL DEFAULT 'active',

  -- Hierarchical relationships
  parent_session_id VARCHAR(255) DEFAULT NULL,
  manual_parent_session_id VARCHAR(255) DEFAULT NULL,
  child_session_ids JSONB NOT NULL DEFAULT '[]'::jsonb,

  -- Agent & session classification
  agent_type VARCHAR(50) DEFAULT NULL,
  is_user_initiated BOOLEAN NOT NULL DEFAULT TRUE,

  -- UI state
  is_pinned BOOLEAN NOT NULL DEFAULT FALSE,
  hidden BOOLEAN NOT NULL DEFAULT FALSE,
  label VARCHAR(255) DEFAULT NULL,

  -- Token usage metrics
  token_usage_input BIGINT NOT NULL DEFAULT 0,
  token_usage_output BIGINT NOT NULL DEFAULT 0,

  -- Audit timestamps
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,

  -- Constraints
  CONSTRAINT chk_end_time CHECK (end_time IS NULL OR end_time >= start_time),
  CONSTRAINT fk_parent_session FOREIGN KEY (parent_session_id)
    REFERENCES sessions(session_id) ON DELETE SET NULL
);

-- Add comments to columns
COMMENT ON TABLE sessions IS 'Claude Code session metadata with hierarchical tracking';
COMMENT ON COLUMN sessions.session_id IS 'Unique session identifier from Claude Code';
COMMENT ON COLUMN sessions.machine_id IS 'Hostname or unique machine identifier';
COMMENT ON COLUMN sessions.working_directory IS 'Working directory where session was initiated';
COMMENT ON COLUMN sessions.start_time IS 'Session start timestamp (Unix ms)';
COMMENT ON COLUMN sessions.end_time IS 'Session end timestamp (Unix ms), NULL if active';
COMMENT ON COLUMN sessions.status IS 'Session status: active, completed, error';
COMMENT ON COLUMN sessions.parent_session_id IS 'Auto-detected parent session ID (from Task tool spawns)';
COMMENT ON COLUMN sessions.manual_parent_session_id IS 'User-overridden parent session ID (set via UI)';
COMMENT ON COLUMN sessions.child_session_ids IS 'Array of child session IDs spawned by this session';
COMMENT ON COLUMN sessions.agent_type IS 'Agent type for sub-agents (e.g., "nexus", "canvas", "archon")';
COMMENT ON COLUMN sessions.is_user_initiated IS 'True if user-initiated, false if spawned via Task tool';
COMMENT ON COLUMN sessions.is_pinned IS 'Whether session is pinned to top of UI list';
COMMENT ON COLUMN sessions.hidden IS 'Whether session is hidden from default view';
COMMENT ON COLUMN sessions.label IS 'Custom session name/label set by user';
COMMENT ON COLUMN sessions.token_usage_input IS 'Total input tokens consumed by session';
COMMENT ON COLUMN sessions.token_usage_output IS 'Total output tokens generated by session';
COMMENT ON COLUMN sessions.created_at IS 'Record creation timestamp';
COMMENT ON COLUMN sessions.updated_at IS 'Record last update timestamp';

-- Indexes for common queries
CREATE INDEX idx_sessions_status ON sessions(status);
CREATE INDEX idx_sessions_parent_session_id ON sessions(parent_session_id);
CREATE INDEX idx_sessions_start_time ON sessions(start_time DESC);
CREATE INDEX idx_sessions_machine_id ON sessions(machine_id);
CREATE INDEX idx_sessions_hidden_status ON sessions(hidden, status, start_time DESC);
CREATE INDEX idx_sessions_pinned ON sessions(is_pinned, start_time DESC);

-- GIN index for efficient child_session_ids JSONB queries
CREATE INDEX idx_sessions_child_ids ON sessions USING GIN (child_session_ids);

-- Partial index for active sessions (most common filter)
CREATE INDEX idx_sessions_active ON sessions(start_time DESC) WHERE status = 'active';

-- Partial index for visible sessions (excludes hidden)
CREATE INDEX idx_sessions_visible ON sessions(start_time DESC) WHERE hidden = FALSE;

-- ============================================================================
-- Events Table
-- ============================================================================
--
-- Stores all monitor events (tool calls, messages, notifications, etc.) with
-- full event payload in JSONB format. Optimized for chronological queries.
--
CREATE TABLE events (
  -- Primary identification
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Session association
  session_id VARCHAR(255) NOT NULL,

  -- Timing
  timestamp BIGINT NOT NULL,

  -- Event classification
  event_type monitor_event_type NOT NULL,
  hook_type claude_hook_type NOT NULL,

  -- Context (denormalized for query performance)
  parent_session_id VARCHAR(255) DEFAULT NULL,
  machine_id VARCHAR(255) NOT NULL,
  working_directory TEXT NOT NULL,

  -- Full event payload (JSONB for efficient indexing)
  data JSONB NOT NULL,

  -- Audit timestamp
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,

  -- Constraints
  CONSTRAINT fk_event_session FOREIGN KEY (session_id)
    REFERENCES sessions(session_id) ON DELETE CASCADE
);

-- Add comments to columns
COMMENT ON TABLE events IS 'Claude Code monitor events with full JSONB payloads';
COMMENT ON COLUMN events.id IS 'UUID for this event';
COMMENT ON COLUMN events.session_id IS 'Session that generated this event';
COMMENT ON COLUMN events.timestamp IS 'Event timestamp (Unix ms)';
COMMENT ON COLUMN events.event_type IS 'Event type: session_start, session_end, tool_call, etc.';
COMMENT ON COLUMN events.hook_type IS 'Claude hook type: PreToolUse, PostToolUse, etc.';
COMMENT ON COLUMN events.parent_session_id IS 'Parent session ID at time of event';
COMMENT ON COLUMN events.machine_id IS 'Machine ID at time of event';
COMMENT ON COLUMN events.working_directory IS 'Working directory at time of event';
COMMENT ON COLUMN events.data IS 'Complete event data: toolName, toolInput, toolOutput, message, thinking, tokenUsage, error, subagent';
COMMENT ON COLUMN events.created_at IS 'Record creation timestamp';

-- Indexes for common query patterns
-- Most common: get events for a session, newest first (covers 95% of queries)
CREATE INDEX idx_events_session_timestamp ON events(session_id, timestamp DESC);

-- Cross-session recent events
CREATE INDEX idx_events_timestamp ON events(timestamp DESC);

-- Event type filtering
CREATE INDEX idx_events_event_type ON events(event_type, timestamp DESC);

-- Machine-specific queries
CREATE INDEX idx_events_machine_timestamp ON events(machine_id, timestamp DESC);

-- Parent session tracking
CREATE INDEX idx_events_parent_session ON events(parent_session_id, timestamp DESC) WHERE parent_session_id IS NOT NULL;

-- GIN index for efficient JSONB queries on event data
CREATE INDEX idx_events_data ON events USING GIN (data);

-- Partial indexes for specific event types (query optimization)
CREATE INDEX idx_events_errors ON events(timestamp DESC) WHERE event_type = 'error';
CREATE INDEX idx_events_tool_calls ON events(session_id, timestamp DESC) WHERE event_type IN ('tool_call', 'tool_result');

-- ============================================================================
-- Triggers
-- ============================================================================

-- Auto-update updated_at timestamp on sessions table
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = CURRENT_TIMESTAMP;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_sessions_updated_at
  BEFORE UPDATE ON sessions
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- ============================================================================
-- Optional: Table Partitioning Configuration
-- ============================================================================
--
-- For high-volume deployments (>10M events), consider partitioning the events
-- table by timestamp range. This requires recreating the table:
--
-- DROP TABLE events CASCADE;
--
-- CREATE TABLE events (
--   -- [same columns as above]
-- ) PARTITION BY RANGE (timestamp);
--
-- CREATE TABLE events_2025_01 PARTITION OF events
--   FOR VALUES FROM (1704067200000) TO (1706745600000);
--
-- CREATE TABLE events_2025_02 PARTITION OF events
--   FOR VALUES FROM (1706745600000) TO (1709251200000);
--
-- -- Continue for each month...
--
-- CREATE TABLE events_default PARTITION OF events DEFAULT;
--
-- Note: Partition management can be automated with pg_partman extension.
-- See: https://github.com/pgpartman/pg_partman

-- ============================================================================
-- Useful Views
-- ============================================================================

-- View for active sessions with computed fields
CREATE OR REPLACE VIEW active_sessions AS
SELECT
  s.session_id,
  s.machine_id,
  s.working_directory,
  s.start_time,
  s.status,
  s.parent_session_id,
  s.agent_type,
  s.is_user_initiated,
  s.is_pinned,
  s.label,
  s.token_usage_input,
  s.token_usage_output,
  s.token_usage_input + s.token_usage_output AS token_usage_total,
  jsonb_array_length(s.child_session_ids) AS child_count,
  CASE
    WHEN s.end_time IS NULL THEN NULL
    ELSE s.end_time - s.start_time
  END AS duration_ms
FROM sessions s
WHERE s.hidden = FALSE
ORDER BY s.is_pinned DESC, s.start_time DESC;

COMMENT ON VIEW active_sessions IS 'Visible sessions with computed metrics';

-- View for session hierarchy
CREATE OR REPLACE VIEW session_hierarchy AS
WITH RECURSIVE session_tree AS (
  -- Root sessions (no parent)
  SELECT
    session_id,
    parent_session_id,
    manual_parent_session_id,
    agent_type,
    start_time,
    status,
    0 AS depth,
    ARRAY[session_id] AS path
  FROM sessions
  WHERE parent_session_id IS NULL

  UNION ALL

  -- Child sessions
  SELECT
    s.session_id,
    s.parent_session_id,
    s.manual_parent_session_id,
    s.agent_type,
    s.start_time,
    s.status,
    st.depth + 1,
    st.path || s.session_id
  FROM sessions s
  INNER JOIN session_tree st ON s.parent_session_id = st.session_id
)
SELECT * FROM session_tree ORDER BY path;

COMMENT ON VIEW session_hierarchy IS 'Recursive session parent-child relationships';

-- ============================================================================
-- Utility Functions
-- ============================================================================

-- Get recent events across all sessions
CREATE OR REPLACE FUNCTION get_recent_events(event_limit INT DEFAULT 100)
RETURNS TABLE (
  id UUID,
  session_id VARCHAR(255),
  timestamp BIGINT,
  event_type monitor_event_type,
  hook_type claude_hook_type,
  data JSONB
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    e.id,
    e.session_id,
    e.timestamp,
    e.event_type,
    e.hook_type,
    e.data
  FROM events e
  ORDER BY e.timestamp DESC
  LIMIT event_limit;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION get_recent_events IS 'Get N most recent events across all sessions';

-- Get session event count by type
CREATE OR REPLACE FUNCTION get_session_event_counts(sid VARCHAR(255))
RETURNS TABLE (
  event_type monitor_event_type,
  event_count BIGINT
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    e.event_type,
    COUNT(*) AS event_count
  FROM events e
  WHERE e.session_id = sid
  GROUP BY e.event_type
  ORDER BY event_count DESC;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION get_session_event_counts IS 'Get event count by type for a specific session';

-- Prune old sessions (returns count deleted)
CREATE OR REPLACE FUNCTION prune_old_sessions(older_than_ms BIGINT)
RETURNS INT AS $$
DECLARE
  deleted_count INT;
BEGIN
  WITH deleted AS (
    DELETE FROM sessions
    WHERE
      end_time IS NOT NULL
      AND end_time < older_than_ms
      AND is_pinned = FALSE
    RETURNING session_id
  )
  SELECT COUNT(*) INTO deleted_count FROM deleted;

  RETURN deleted_count;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION prune_old_sessions IS 'Delete completed sessions older than timestamp (excludes pinned)';

-- ============================================================================
-- Index Usage Notes
-- ============================================================================
--
-- sessions table:
--   - idx_sessions_status: Filter active/completed sessions
--   - idx_sessions_parent_session_id: Navigate session hierarchy
--   - idx_sessions_start_time: Sort sessions chronologically
--   - idx_sessions_hidden_status: Filter visible/hidden sessions
--   - idx_sessions_pinned: Sort pinned sessions to top
--   - idx_sessions_child_ids: GIN index for JSONB child array queries
--   - idx_sessions_active: Partial index for active sessions only
--   - idx_sessions_visible: Partial index excluding hidden sessions
--
-- events table:
--   - idx_events_session_timestamp: PRIMARY query pattern (95% of queries)
--   - idx_events_timestamp: Cross-session "recent activity" view
--   - idx_events_event_type: Filter by event type
--   - idx_events_machine_timestamp: Machine-specific monitoring
--   - idx_events_parent_session: Track events across session trees
--   - idx_events_data: GIN index for JSONB queries (e.g., toolName filter)
--   - idx_events_errors: Partial index for error events only
--   - idx_events_tool_calls: Partial index for tool-related events
--
-- ============================================================================
-- Migration & Maintenance
-- ============================================================================
--
-- To apply this schema:
--   1. Create database: CREATE DATABASE contextuate_monitor;
--   2. Connect to database: \c contextuate_monitor
--   3. Run this script: \i postgresql-schema.sql
--
-- To reset for testing:
--   DROP DATABASE IF EXISTS contextuate_monitor;
--   CREATE DATABASE contextuate_monitor;
--   \c contextuate_monitor
--   \i postgresql-schema.sql
--
-- Regular maintenance:
--   - Analyze tables: ANALYZE sessions; ANALYZE events;
--   - Vacuum: VACUUM ANALYZE events;
--   - Check index usage: SELECT * FROM pg_stat_user_indexes WHERE schemaname = 'public';
--   - Archive old events: Use prune_old_sessions() function
--
-- Performance monitoring:
--   - Query stats: SELECT * FROM pg_stat_statements WHERE query LIKE '%events%';
--   - Table sizes: SELECT pg_size_pretty(pg_total_relation_size('events'));
--   - Index sizes: SELECT pg_size_pretty(pg_relation_size('idx_events_session_timestamp'));
--
-- ============================================================================
