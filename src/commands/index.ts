import chalk from 'chalk';
import fs from 'fs-extra';
import path from 'path';
import { generateFileTree, estimateTokens } from '../utils/tokens';

export async function indexCommand(options: { depth?: string, force?: boolean }) {
    console.log(chalk.blue('[INFO] Generating project index...'));

    const depth = options.depth ? parseInt(options.depth) : 5;
    const projectRoot = process.cwd();
    const destDir = path.join(projectRoot, 'docs/ai');
    const destFile = path.join(destDir, 'project-structure.md');

    // Ensure docs/ai exists
    await fs.ensureDir(destDir);

    try {
        const tree = await generateFileTree(projectRoot, depth);
        const tokens = estimateTokens(tree);

        const content = `# Project Structure Index
<!-- 
  GENERATED FILE - DO NOT EDIT MANUALLY
  Generated by: contextuate index
  Tokens: ~${tokens}
-->

\`\`\`
${tree}
\`\`\`
`;

        if (await fs.pathExists(destFile) && !options.force) {
            // Check if content is different? For now just overwrite if forced or tell user
            // Actually, index is meant to be regenerated. We'll overwrite but log it.
            // console.log(chalk.yellow(`[WARN] Overwriting existing index at ${destFile}`));
        }

        await fs.writeFile(destFile, content);

        console.log(chalk.green(`[OK] Generated index at: ${destFile}`));
        console.log(`     Size: ${chalk.cyan(tokens + ' tokens')} (approx)`);
        console.log(`     Use this file to give agents a high-level map of the codebase.`);

    } catch (e: any) {
        console.error(chalk.red(`[ERROR] Failed to generate index: ${e.message}`));
    }
}
