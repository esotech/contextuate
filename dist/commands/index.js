"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.indexCommand = indexCommand;
const chalk_1 = __importDefault(require("chalk"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const tokens_1 = require("../utils/tokens");
async function indexCommand(options) {
    console.log(chalk_1.default.blue('[INFO] Generating project index...'));
    const depth = options.depth ? parseInt(options.depth) : 5;
    const projectRoot = process.cwd();
    const destDir = path_1.default.join(projectRoot, 'docs/ai');
    const destFile = path_1.default.join(destDir, 'project-structure.md');
    // Ensure docs/ai exists
    await fs_extra_1.default.ensureDir(destDir);
    try {
        const tree = await (0, tokens_1.generateFileTree)(projectRoot, depth);
        const tokens = (0, tokens_1.estimateTokens)(tree);
        const content = `# Project Structure Index
<!-- 
  GENERATED FILE - DO NOT EDIT MANUALLY
  Generated by: contextuate index
  Tokens: ~${tokens}
-->

\`\`\`
${tree}
\`\`\`
`;
        if (await fs_extra_1.default.pathExists(destFile) && !options.force) {
            // Check if content is different? For now just overwrite if forced or tell user
            // Actually, index is meant to be regenerated. We'll overwrite but log it.
            // console.log(chalk.yellow(`[WARN] Overwriting existing index at ${destFile}`));
        }
        await fs_extra_1.default.writeFile(destFile, content);
        console.log(chalk_1.default.green(`[OK] Generated index at: ${destFile}`));
        console.log(`     Size: ${chalk_1.default.cyan(tokens + ' tokens')} (approx)`);
        console.log(`     Use this file to give agents a high-level map of the codebase.`);
    }
    catch (e) {
        console.error(chalk_1.default.red(`[ERROR] Failed to generate index: ${e.message}`));
    }
}
